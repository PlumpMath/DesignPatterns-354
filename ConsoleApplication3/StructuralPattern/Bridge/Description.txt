Мост (Bridge) - структурный шаблон проектирования, который позволяет отделить абстракцию от реализации таким образом, чтобы и абстракцию, 
и реализацию можно было изменять независимо друг от друга.

Даже если мы отделим абстракцию от конкретных реализаций, то у нас все равно все наследуемые классы будут жестко привязаны к интерфейсу, 
определяемому в базовом абстрактном классе. Для преодоления жестких связей и служит паттерн Мост.

Когда использовать данный паттерн?

    Когда надо избежать постоянной привязки абстракции к реализации

    Когда наряду с реализацией надо изменять и абстракцию независимо друг от друга. То есть изменения в абстракции не должно привести к изменениям в реализации

Общая реализация паттерна состоит в объявлении классов абстракций и классов реализаций в отдельных параллельных иерархиях классов.

Связь агрегации между классами Abstraction и Implementor фактически и представляет некоторый мост между двумя параллельными иерархиями классов. 
Собственно поэтому паттерн получил название Мост.

----------------------------------------------------------------------------------
class Client
{
    static void Main()
    {
        Abstraction abstraction;
        abstraction = new RefinedAbstraction(new ConcreteImplementorA());
        abstraction.Operation();
        abstraction.Implementor=new ConcreteImplementorB();
        abstraction.Operation();
    }
}
abstract class Abstraction
{
    protected Implementor implementor;
    public Implementor Implementor
    {
        set { implementor = value; }
    }
    public Abstraction(Implementor imp)
    {
        implementor = imp;
    }
    public virtual void Operation()
    {
        implementor.OperationImp();
    }
}
 
abstract class Implementor
{
    public abstract void OperationImp();
}
 
class RefinedAbstraction : Abstraction
{
    public RefinedAbstraction(Implementor imp)
        : base(imp)
    {}
    public override void Operation()
    {
    }
}
 
class ConcreteImplementorA : Implementor
{
    public override void OperationImp()
    {
    }
}
 
class ConcreteImplementorB : Implementor
{
    public override void OperationImp()
    {
    }
}
----------------------------------------------------------------------------------
Участники

    Abstraction: определяет базовый интерфейс и хранит ссылку на объект Implementor. Выполнение операций в Abstraction делегируется методам объекта Implementor

    RefinedAbstraction: уточненная абстракция, наследуется от Abstraction и расширяет унаследованный интерфейс

    Implementor: определяет базовый интерфейс для конкретных реализаций. Как правило, Implementor определяет только примитивные операции. 
	Более сложные операции, которые базируются на примитивных, определяются в Abstraction

    ConcreteImplementorA и ConcreteImplementorB: конкретные реализации, которые унаследованы от Implementor

    Client: использует объекты Abstraction
----------------------------------------------------------------------------------
Представим ситуацию, когда вам требуется работать на разных автомобилях, однако садясь в новый автомобиль вам уже желательно знать как им управлять. 
Таким образом вы сталкиваетесь с паттерном «мост». С одной стороны вы имеете множество различных автомобилей (разные модели и марки), 
но среди все них есть общая абстракция (интерфейс) ввиде руля, педалей, коробки передач и так далее. 
Таким образом мы задаем как-бы правила изготовления автомобилей по которым мы можем создавать любые их виды, но за счет сохранения общих правил взаимодействия с ними, 
мы можем одинаково управлять каждым из них. «Мостом» в данном случае является пара двух «объектов»: 
конкретного автомобиля и правил взаимодействия с этим (и любым другим) автомобилем.
