Декоратор (Decorator) представляет структурный шаблон проектирования, который позволяет динамически подключать к объекту дополнительную функциональность.

Для определения нового функционала в классах нередко используется наследование. Декораторы же предоставляет наследованию более гибкую альтернативу, 
поскольку позволяют динамически в процессе выполнения определять новые возможности у объектов.


Когда следует использовать декораторы?

Когда надо динамически добавлять к объекту новые функциональные возможности. При этом данные возможности могут быть сняты с объекта

Когда применение наследования неприемлемо. Например, если нам надо определить множество различных функциональностей и 
для каждой функциональности наследовать отдельный класс, то структура классов может очень сильно разрастись. 
Еще больше она может разрастись, если нам необходимо создать классы, реализующие все возможные сочетания добавляемых функциональностей.

----------------------------------------------------------------------------------------
abstract class Component
{
    public abstract void Operation();
}
class ConcreteComponent : Component
{
    public override void Operation()
    {}
}
abstract class Decorator : Component
{
    protected Component component;
 
    public void SetComponent(Component component)
    {
        this.component = component;
    }
 
    public override void Operation()
    {
        if (component != null)
            component.Operation();
    }
}
class ConcreteDecoratorA : Decorator
{
    public Object NewState { get; set; }
    public override void Operation()
    {
        base.Operation();
    }
}
class ConcreteDecoratorB : Decorator
{
    public override void Operation()
    {
        base.Operation();
    }
    public void NewMethod()
    {
    }
}
----------------------------------------------------------------------------------------
Участники

    Component: абстрактный класс, который определяет интерфейс для наследуемых объектов

    ConcreteComponent: конкретная реализация компонента, в которую с помощью декоратора добавляется новая функциональность

    Decorator: собственно декоратор, реализуется в виде абстрактного класса и имеет тот же базовый класс, что и декорируемые объекты. 
	Поэтому базовый класс Component должен быть по возможности легким и определять только базовый интерфейс.

    Класс декоратора также хранит ссылку на декорируемый объект в виде объекта базового класса Component и реализует связь с базовым классом как через наследование, 
	так и через отношение агрегации.

    Классы ConcreteDecoratorA и ConcreteDecoratorB представляют дополнительные функциональности, которыми должен быть расширен объект ConcreteComponent. 
	ConcreteDecoratorA добавляет новое свойство NewState, а ConcreteDecoratorB добавляет новый метод NewMethod(). Подобных классов может быть множество. 
	И они не обязательно должны что-то добавлять: свойства, методы. Они просто могут переопределять уже имеющийся функционал.
-------------------------------------------------------------------------
Как понятно из названия, данный паттерн чаще всего используется для расширения исходного объекта до требуемого вида. 
Например мы условно можем считать «декоратором» человека с кистью и красной краской. 
Таким образом, какой бы объект (или определенный тип объектов) мы не передали в руки «декоратору», на выходе мы будем получать красные объекты.