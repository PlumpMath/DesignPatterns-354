Паттерн Итератор (Iterator) предоставляет абстрактный интерфейс для последовательного доступа ко всем элементам составного объекта 
без раскрытия его внутренней структуры.

Ключевым моментом, который позволяет осуществить перебор коллекций с помощью foreach, 
является применения этими классами коллекций паттерна итератор, или проще говоря пары интерфейсов IEnumerable / IEnumerator. 
Интерфейс IEnumerator определяет функционал для перебора внутренних объектов в контейнере

-------------------------------------
public interface IEnumerator
{
    bool MoveNext(); // перемещение на одну позицию вперед в контейнере элементов
    object Current {get;}  // текущий элемент в контейнере
    void Reset(); // перемещение в начало контейнера
}

public interface IEnumerable
{
    IEnumerator GetEnumerator();
}
-------------------------------------
Используя данные интерфейсы, мы можем свести к одному шаблону - с помощью цикла foreach - любые составные объекты.

Когда использовать итераторы?

    Когда необходимо осуществить обход объекта без раскрытия его внутренней структуры

    Когда имеется набор составных объектов, и надо обеспечить единый интерфейс для их перебора

    Когда необходимо предоставить несколько альтернативных вариантов перебора одного и того же объекта


----------------------------------------------------------------------------------
class Client
{
    public void Main()
    {
        Aggregate a = new ConcreteAggregate();
             
        Iterator i = a.CreateIterator();
 
        object item = i.First();
        while (!i.IsDone())
        {
            item = i.Next();
        }
    }
}
 
abstract class Aggregate
{
    public abstract Iterator CreateIterator();
    public abstract int Count { get; protected set; }
    public abstract object this[int index] { get; set; }
}
  
class ConcreteAggregate : Aggregate
{
    private readonly ArrayList _items = new ArrayList();
  
    public override Iterator CreateIterator()
    {
        return new ConcreteIterator(this);
    }
  
    public override int Count
    {
        get { return _items.Count; }
        protected set { }
    }
 
    public override object this[int index]
    {
        get { return _items[index]; }
        set { _items.Insert(index, value); }
    }
}
abstract class Iterator
{
    public abstract object First();
    public abstract object Next();
    public abstract bool IsDone();
    public abstract object CurrentItem();
}
  
class ConcreteIterator : Iterator
{
    private readonly Aggregate _aggregate;
    private int _current;
  
    public ConcreteIterator(Aggregate aggregate)
    {
        this._aggregate = aggregate;
    }
  
    public override object First()
    {
        return _aggregate[0];
    }
  
    public override object Next()
    {
        object ret = null;
  
        _current++;
  
        if (_current < _aggregate.Count)
        {
            ret = _aggregate[_current];
        }
  
        return ret;
    }
  
    public override object CurrentItem()
    {
        return _aggregate[_current];
    }
  
    public override bool IsDone()
    {
        return _current >= _aggregate.Count;
    }
}
----------------------------------------------------------------------------------
Участники

    Iterator: определяет интерфейс для обхода составных объектов

    Aggregate: определяет интерфейс для создания объекта-итератора

    ConcreteIterator: конкретная реализация итератора для обхода объекта Aggregate. 
	Для фиксации индекса текущего перебираемого элемента использует целочисленную переменную _current

    ConcreteAggregate: конкретная реализация Aggregate. Хранит элементы, которые надо будет перебирать

    Client: использует объект Aggregate и итератор для его обхода


----------------------------------------------------------

https://habrahabr.ru/post/148905/
Утиная типизация (англ. Duck typing) — вид динамической типизации, применяемой в некоторых языках программирования, 
когда границы использования объекта определяются его текущим набором методов и свойств, в противоположность 
наследованию от определённого класса. (Если это выглядит как утка, плавает как утка и крякает как утка, то это возможно и есть утка.)

Я думаю, что многие разработчики знают, что цикл foreach в языке C# не так прост, каким он кажется на первый взгляд. 
Для начала давайте ответим на вопрос: «А что нужно, чтобы конструкция foreach успешно компилировалась?». 
Интуитивным ответом на этот вопрос кажется что-то типа: «Реализация классом интерфейса IEnumerable или IEnumerable<T>.». 
Однако, это не так, ну, или не совсем так.

Полный ответ на этот вопрос такой: «Для того чтобы конструкция foreach успешно компилировалась необходимо, 
чтобы у объекта был метод GetEnumerator(), который вернет объект с методом MoveNext() и свойством Current, 
а если такого метода нет, то тогда будем искать интерфейсы IEnumerable и IEnumerable<T>».

Причин у такого «утиного» поведения две.


Давайте вспомним старые времена языка C# 1.0, когда язык был простым и понятным, и в нем не было никаких обобщений (generics), 
LINQ-ов и других замыканий. Но раз не было generic-ов, то «обобщение» и повторное использование было основано 
на полиморфизме и типе object, что, собственно и делалось в классах коллекций и их итераторов.

В качестве этих самых итераторов выступали пара интерфейсов IEnumerable и IEnumerator, при этом последний в свойстве Current возвращал object. 
А раз так, то использование интерфейса IEnumerator для перебора элементов строго типизированной коллекции значимых типов приводило бы 
к упаковке и распаковке этого значения на каждой итерации, что, согласитесь, может быть весьма накладно, 
когда речь идет о столь распространенной операции как перебор элементов.

Чтобы решить эту проблему и было принято решение использовать хак с утиной типизацией, и забить немного на принципы ООП в угоду 
производительности. В таком случае, класс мог реализовать интерфейс IEnumerable явно и предоставить дополнительный метод GetEnumerator(), 
который бы возвращал строготипизированный енумератор, свойство Current которого возвращало конкретный тип, например, 
DateTime без какой либо упаковки.
----------------------------------------------------------

Все помнят школьное «на первый второй рассчитайся!»? Вот именно в этот момент шеренга вашего класса и являлась реализацией паттерна «итератор», 
хотя в программировании это конечно более функциональное понятие, но суть примерно та же. «Итератор» предоставляет правила доступа к списку каких-либо объектов независимо от того, 
что это за объекты. То есть не важно какой именно класс построен и из каких учеников, должны быть общие правила подсчета и обращения как каждому ученику по списку, 
вроде «13-ый, выйти из строя». Нередко паттерн «итератор» используется для доступа к «реестру». Ссылки, которые вы видите на многих сайтах для переходов по страницам, 
вроде «следующая», «предыдущая», «в начало» и т.п. по своей сути также являются доступом «итератору» который отвечает за страницы сайта.